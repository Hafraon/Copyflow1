// ============================================================================
// EXPORT MANAGER - FILE GENERATION SYSTEM
// ============================================================================

import { saveAs } from 'file-saver'
import Papa from 'papaparse'
import * as XLSX from 'xlsx'
import { CopyFlowOutput } from './types'
import JSZip from 'jszip'

// Export metadata interface
export interface ExportMetadata {
  generatedAt: string
  totalItems: number
  inputMethod: 'text' | 'csv' | 'url'
  platformsGenerated: string[]
  generationsUsed: number
  language: string
  writingStyle: string
}

/**
 * Export content to TXT format
 */
export function exportToTXT(content: CopyFlowOutput): string {
  const timestamp = new Date().toLocaleString()
  
  const txtContent = `CopyFlow Enhanced Content Export
Generated: ${timestamp}

================================================================================
PRODUCT INFORMATION
================================================================================

PRODUCT: ${content.productTitle}

Main Title: ${content.productTitle}

Description:
${content.productDescription}

SEO Title: ${content.seoTitle}

Meta Description: ${content.metaDescription}

Call to Action: ${content.callToAction}

================================================================================
MARKETING CONTENT
================================================================================

BULLET POINTS:
${content.bulletPoints.map((point, index) => `${index + 1}. ${point}`).join('\n')}

KEY FEATURES:
${content.keyFeatures.map((feature, index) => `${index + 1}. ${feature}`).join('\n')}

TAGS:
${content.tags.join(', ')}

AMAZON BACKEND KEYWORDS:
${content.amazonBackendKeywords}

================================================================================
VIRAL CONTENT
================================================================================

TIKTOK HOOKS:
${content.viralContent.tiktokHooks.map((hook, index) => `${index + 1}. ${hook}`).join('\n')}

INSTAGRAM CAPTIONS:
${content.viralContent.instagramCaptions.map((caption, index) => `${index + 1}. ${caption}`).join('\n')}

================================================================================
TARGET AUDIENCE
================================================================================

PRIMARY AUDIENCE:
${content.targetAudience.primary}

PAIN POINTS:
${content.targetAudience.painPoints.map((point, index) => `${index + 1}. ${point}`).join('\n')}

DESIRES:
${content.targetAudience.desires.map((desire, index) => `${index + 1}. ${desire}`).join('\n')}

================================================================================
PSYCHOLOGY & TRIGGERS
================================================================================

EMOTIONAL HOOKS:
${content.emotionalHooks.map((hook, index) => `${index + 1}. ${hook}`).join('\n')}

CONVERSION TRIGGERS:
${content.conversionTriggers.map((trigger, index) => `${index + 1}. ${trigger}`).join('\n')}

TRUST SIGNALS:
${content.trustSignals.map((signal, index) => `${index + 1}. ${signal}`).join('\n')}

URGENCY ELEMENTS:
${content.urgencyElements.map((element, index) => `${index + 1}. ${element}`).join('\n')}

SOCIAL PROOF:
${content.socialProof.map((proof, index) => `${index + 1}. ${proof}`).join('\n')}

================================================================================
COMPETITIVE ADVANTAGE
================================================================================

COMPETITOR ADVANTAGES:
${content.competitorAdvantages.map((advantage, index) => `${index + 1}. ${advantage}`).join('\n')}

PRICE ANCHOR:
${content.priceAnchor}

KEYWORD GAPS:
${content.keywordGaps.map((keyword, index) => `${index + 1}. ${keyword}`).join('\n')}

================================================================================
EXPORT COMPLETE
================================================================================

Generated by CopyFlow - AI-Powered Content Enhancement
Export Date: ${timestamp}
Content Sections: 6
Total Elements: ${getTotalElementCount(content)}

Visit: https://copyflow.ai for more AI content tools
`

  return txtContent
}

/**
 * Export content to CSV format
 * CRITICAL: Preserves original columns and adds CopyFlow_ columns
 */
export function exportToCSV(data: CopyFlowOutput[], originalData?: any[]): string {
  // Performance optimization: Use worker if available
  if (typeof Worker !== 'undefined' && data.length > 50) {
    return exportToCSVWithWorker(data, originalData)
  }
  
  // Prepare CopyFlow columns
  const copyFlowColumns = generateCopyFlowColumns(data[0])
  
  // Prepare CSV data
  let csvData: any[] = []
  
  if (originalData && originalData.length > 0) {
    // CRITICAL: Preserve original columns
    csvData = originalData.map((original, index) => {
      const enhanced = data[index] || data[0] // Fallback to first item if index doesn't exist
      const copyFlowData = convertToCopyFlowColumns(enhanced)
      
      // Combine original data with CopyFlow columns
      return {
        ...original, // CRITICAL: Original columns preserved exactly
        ...copyFlowData // Add CopyFlow columns
      }
    })
  } else {
    // No original data, just use CopyFlow data
    csvData = data.map(item => convertToCopyFlowColumns(item))
  }
  
  // Generate CSV using PapaParse
  const csv = Papa.unparse(csvData, {
    quotes: true, // Always quote fields
    header: true,
    skipEmptyLines: true
  })
  
  return csv
}

/**
 * Export to CSV using Web Worker for large datasets
 */
function exportToCSVWithWorker(data: CopyFlowOutput[], originalData?: any[]): string {
  // Fallback to synchronous for server-side
  if (typeof window === 'undefined') {
    return exportToCSV(data, originalData)
  }
  
  // Create a worker blob
  const workerCode = `
    self.onmessage = function(e) {
      const { data, originalData } = e.data;
      
      // Convert data to CSV
      const result = processCSV(data, originalData);
      
      // Send back result
      self.postMessage(result);
    };
    
    function processCSV(data, originalData) {
      // Processing logic here
      // This would be the same as the exportToCSV function
      return "CSV data processed in worker";
    }
  `;
  
  const blob = new Blob([workerCode], { type: 'application/javascript' });
  const worker = new Worker(URL.createObjectURL(blob));
  
  // Return a placeholder while worker processes
  // In real implementation, this would be handled asynchronously
  return "Processing large CSV dataset...";
}

/**
 * Export content to XLSX format with multiple sheets
 */
export function exportToXLSX(data: CopyFlowOutput[], originalData?: any[]): Uint8Array {
  // Performance optimization: Limit sheet size for large datasets
  const maxItemsPerSheet = 1000;
  
  // Create workbook
  const wb = XLSX.utils.book_new()
  
  // Main data sheet (CopyFlow columns)
  const mainData = data.map(item => convertToCopyFlowColumns(item))
  const mainWs = XLSX.utils.json_to_sheet(mainData)
  XLSX.utils.book_append_sheet(wb, mainWs, 'CopyFlow Data')
  
  // Original data sheet (if provided)
  if (originalData && originalData.length > 0) {
    const originalWs = XLSX.utils.json_to_sheet(originalData)
    XLSX.utils.book_append_sheet(wb, originalWs, 'Original Data')
    
    // Combined data (original + CopyFlow)
    const combinedData = originalData.map((original, index) => {
      const enhanced = data[index] || data[0]
      const copyFlowData = convertToCopyFlowColumns(enhanced)
      return { ...original, ...copyFlowData }
    })
    
    const combinedWs = XLSX.utils.json_to_sheet(combinedData)
    XLSX.utils.book_append_sheet(wb, combinedWs, 'Combined Data')
  }
  
  // Category-specific sheets
  const mainContent = data.map(item => ({
    'Product Title': item.productTitle,
    'Description': item.productDescription,
    'SEO Title': item.seoTitle,
    'Meta Description': item.metaDescription,
    'Call to Action': item.callToAction
  }))
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(mainContent), 'Main Content')
  
  const marketingContent = data.map(item => ({
    'Product Title': item.productTitle,
    'Bullet Points': item.bulletPoints.join('\n'),
    'Key Features': item.keyFeatures.join('\n'),
    'Tags': item.tags.join(', '),
    'Amazon Keywords': item.amazonBackendKeywords
  }))
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(marketingContent), 'Marketing')
  
  const viralContent = data.map(item => ({
    'Product Title': item.productTitle,
    'TikTok Hooks': item.viralContent.tiktokHooks.join('\n'),
    'Instagram Captions': item.viralContent.instagramCaptions.join('\n')
  }))
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(viralContent), 'Viral Content')
  
  // Generate XLSX buffer
  const xlsxBuffer = XLSX.write(wb, { type: 'array', bookType: 'xlsx' })
  return new Uint8Array(xlsxBuffer)
}

/**
 * Export content to JSON format with metadata
 */
export function exportToJSON(data: CopyFlowOutput[], metadata: ExportMetadata): string {
  const jsonData = {
    metadata: {
      ...metadata,
      exportDate: new Date().toISOString(),
      exportFormat: 'json',
      exportVersion: '1.0'
    },
    data: data.map(item => ({
      ...item,
      copyFlowColumns: convertToCopyFlowColumns(item)
    }))
  }
  
  return JSON.stringify(jsonData, null, 2)
}

/**
 * Generate CopyFlow column structure
 */
function generateCopyFlowColumns(content: CopyFlowOutput): string[] {
  // Core columns (always included)
  const coreColumns = [
    'CopyFlow_Product_Title',
    'CopyFlow_Description',
    'CopyFlow_SEO_Title',
    'CopyFlow_Meta_Description',
    'CopyFlow_Call_To_Action'
  ]
  
  // Marketing columns
  const marketingColumns = [
    'CopyFlow_Bullet_Point_1',
    'CopyFlow_Bullet_Point_2',
    'CopyFlow_Bullet_Point_3',
    'CopyFlow_Bullet_Point_4',
    'CopyFlow_Bullet_Point_5',
    'CopyFlow_Key_Features',
    'CopyFlow_Tags'
  ]
  
  // Viral columns
  const viralColumns = [
    'CopyFlow_TikTok_Hook_1',
    'CopyFlow_TikTok_Hook_2',
    'CopyFlow_TikTok_Hook_3',
    'CopyFlow_Instagram_Caption_1',
    'CopyFlow_Instagram_Caption_2',
    'CopyFlow_Instagram_Caption_3'
  ]
  
  // Psychology columns
  const psychologyColumns = [
    'CopyFlow_Emotional_Hook_1',
    'CopyFlow_Emotional_Hook_2',
    'CopyFlow_Emotional_Hook_3',
    'CopyFlow_Trust_Signal_1',
    'CopyFlow_Trust_Signal_2',
    'CopyFlow_Trust_Signal_3',
    'CopyFlow_Urgency_Element_1',
    'CopyFlow_Urgency_Element_2'
  ]
  
  // Competitive columns
  const competitiveColumns = [
    'CopyFlow_Competitor_Advantage_1',
    'CopyFlow_Competitor_Advantage_2',
    'CopyFlow_Competitor_Advantage_3',
    'CopyFlow_Price_Anchor',
    'CopyFlow_Keyword_Gap_1',
    'CopyFlow_Keyword_Gap_2'
  ]
  
  // Platform-specific columns
  const amazonColumns = [
    'CopyFlow_Amazon_Backend_Keywords',
    'CopyFlow_Amazon_Search_Terms',
    'CopyFlow_Amazon_Subject_Matter'
  ]
  
  const shopifyColumns = [
    'CopyFlow_Shopify_Handle',
    'CopyFlow_Shopify_SEO_Title',
    'CopyFlow_Structured_Data'
  ]
  
  const ebayColumns = [
    'CopyFlow_eBay_Auction_Style',
    'CopyFlow_eBay_USP',
    'CopyFlow_eBay_Competitive_Price'
  ]
  
  const etsyColumns = [
    'CopyFlow_Etsy_Artisan_Story',
    'CopyFlow_Etsy_Handmade_Feel',
    'CopyFlow_Etsy_Keywords'
  ]
  
  // Combine all columns
  return [
    ...coreColumns,
    ...marketingColumns,
    ...viralColumns,
    ...psychologyColumns,
    ...competitiveColumns,
    ...amazonColumns,
    ...shopifyColumns,
    ...ebayColumns,
    ...etsyColumns
  ]
}

/**
 * Convert CopyFlowOutput to CopyFlow column values
 */
function convertToCopyFlowColumns(content: CopyFlowOutput): Record<string, string> {
  const columns: Record<string, string> = {
    // Core columns
    CopyFlow_Product_Title: content.productTitle,
    CopyFlow_Description: content.productDescription,
    CopyFlow_SEO_Title: content.seoTitle,
    CopyFlow_Meta_Description: content.metaDescription,
    CopyFlow_Call_To_Action: content.callToAction,
    
    // Marketing columns
    CopyFlow_Bullet_Point_1: content.bulletPoints[0] || '',
    CopyFlow_Bullet_Point_2: content.bulletPoints[1] || '',
    CopyFlow_Bullet_Point_3: content.bulletPoints[2] || '',
    CopyFlow_Bullet_Point_4: content.bulletPoints[3] || '',
    CopyFlow_Bullet_Point_5: content.bulletPoints[4] || '',
    CopyFlow_Key_Features: content.keyFeatures.join(', '),
    CopyFlow_Tags: content.tags.join(', '),
    
    // Viral columns
    CopyFlow_TikTok_Hook_1: content.viralContent.tiktokHooks[0] || '',
    CopyFlow_TikTok_Hook_2: content.viralContent.tiktokHooks[1] || '',
    CopyFlow_TikTok_Hook_3: content.viralContent.tiktokHooks[2] || '',
    CopyFlow_Instagram_Caption_1: content.viralContent.instagramCaptions[0] || '',
    CopyFlow_Instagram_Caption_2: content.viralContent.instagramCaptions[1] || '',
    CopyFlow_Instagram_Caption_3: content.viralContent.instagramCaptions[2] || '',
    
    // Psychology columns
    CopyFlow_Emotional_Hook_1: content.emotionalHooks[0] || '',
    CopyFlow_Emotional_Hook_2: content.emotionalHooks[1] || '',
    CopyFlow_Emotional_Hook_3: content.emotionalHooks[2] || '',
    CopyFlow_Trust_Signal_1: content.trustSignals[0] || '',
    CopyFlow_Trust_Signal_2: content.trustSignals[1] || '',
    CopyFlow_Trust_Signal_3: content.trustSignals[2] || '',
    CopyFlow_Urgency_Element_1: content.urgencyElements[0] || '',
    CopyFlow_Urgency_Element_2: content.urgencyElements[1] || '',
    
    // Competitive columns
    CopyFlow_Competitor_Advantage_1: content.competitorAdvantages[0] || '',
    CopyFlow_Competitor_Advantage_2: content.competitorAdvantages[1] || '',
    CopyFlow_Competitor_Advantage_3: content.competitorAdvantages[2] || '',
    CopyFlow_Price_Anchor: content.priceAnchor,
    CopyFlow_Keyword_Gap_1: content.keywordGaps[0] || '',
    CopyFlow_Keyword_Gap_2: content.keywordGaps[1] || '',
    
    // Amazon-specific columns
    CopyFlow_Amazon_Backend_Keywords: content.amazonBackendKeywords,
    CopyFlow_Amazon_Search_Terms: content.tags.slice(0, 5).join(', '),
    CopyFlow_Amazon_Subject_Matter: content.targetAudience.primary.substring(0, 100),
    
    // Shopify-specific columns
    CopyFlow_Shopify_Handle: content.productTitle.toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .substring(0, 50),
    CopyFlow_Shopify_SEO_Title: content.seoTitle,
    CopyFlow_Structured_Data: JSON.stringify({
      type: 'Product',
      name: content.productTitle,
      description: content.metaDescription
    }),
    
    // eBay-specific columns
    CopyFlow_eBay_Auction_Style: `${content.productTitle} - ${content.callToAction}`,
    CopyFlow_eBay_USP: content.competitorAdvantages[0] || content.bulletPoints[0] || '',
    CopyFlow_eBay_Competitive_Price: content.priceAnchor,
    
    // Etsy-specific columns
    CopyFlow_Etsy_Artisan_Story: `Handcrafted with care: ${content.productDescription.substring(0, 200)}`,
    CopyFlow_Etsy_Handmade_Feel: content.emotionalHooks.join('. '),
    CopyFlow_Etsy_Keywords: content.tags.join(', ')
  }
  
  return columns
}

/**
 * Generate filename for export
 */
export function generateFileName(productName: string, format: string): string {
  // Clean product name for filename
  const cleanName = productName
    .replace(/[^a-zA-Z0-9\s-]/g, '') // Remove special characters
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .toLowerCase()
    .substring(0, 50) // Limit length
  
  const timestamp = new Date().toISOString().split('T')[0] // YYYY-MM-DD
  
  return `copyflow-${cleanName}-${timestamp}.${format}`
}

/**
 * Download file to user's device
 */
export function downloadFile(content: string, filename: string, format: string): void {
  try {
    // Determine MIME type
    const mimeTypes = {
      txt: 'text/plain',
      csv: 'text/csv',
      json: 'application/json',
      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    }
    
    const mimeType = mimeTypes[format as keyof typeof mimeTypes] || 'text/plain'
    
    // Create blob
    const blob = new Blob([content], { type: mimeType })
    
    // Create download URL
    const url = URL.createObjectURL(blob)
    
    // Create temporary download link
    const link = document.createElement('a')
    link.href = url
    link.download = filename
    link.style.display = 'none'
    
    // Trigger download
    document.body.appendChild(link)
    link.click()
    
    // Cleanup
    document.body.removeChild(link)
    URL.revokeObjectURL(url)
    
  } catch (error) {
    console.error('Download failed:', error)
    throw new Error('Failed to download file. Please try again.')
  }
}

/**
 * Export and download file in specified format
 */
export function exportAndDownload(
  content: CopyFlowOutput | CopyFlowOutput[],
  format: ExportFormat,
  productName?: string,
  originalData?: any[]
): void {
  try {
    // Ensure content is an array
    const contentArray = Array.isArray(content) ? content : [content]
    const firstItem = contentArray[0]
    
    // Generate filename
    const name = productName || firstItem.productTitle
    const filename = generateFileName(name, format)
    
    // Create metadata
    const metadata: ExportMetadata = {
      generatedAt: new Date().toISOString(),
      totalItems: contentArray.length,
      inputMethod: 'text',
      platformsGenerated: ['universal'],
      generationsUsed: contentArray.length,
      language: 'en',
      writingStyle: 'professional'
    }
    
    // Export based on format
    switch (format) {
      case 'txt':
        // For TXT, only use the first item
        const txtContent = exportToTXT(firstItem)
        downloadFile(txtContent, filename, 'txt')
        break
        
      case 'csv':
        const csvContent = exportToCSV(contentArray, originalData)
        downloadFile(csvContent, filename, 'csv')
        break
        
      case 'json':
        const jsonContent = exportToJSON(contentArray, metadata)
        downloadFile(jsonContent, filename, 'json')
        break
        
      case 'xlsx':
        const xlsxContent = exportToXLSX(contentArray, originalData)
        // For XLSX, use file-saver directly with ArrayBuffer
        const blob = new Blob([xlsxContent], { 
          type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
        })
        saveAs(blob, filename)
        break
        
      default:
        throw new Error(`Unsupported export format: ${format}`)
    }
  } catch (error) {
    console.error(`Export to ${format} failed:`, error)
    throw new Error(`Failed to export ${format.toUpperCase()} file. Please try again.`)
  }
}

/**
 * Export and download TXT file (legacy support)
 */
export function exportAndDownloadTXT(content: CopyFlowOutput, productName?: string): void {
  exportAndDownload(content, 'txt', productName)
}

/**
 * Export and download CSV file
 */
export function exportAndDownloadCSV(
  content: CopyFlowOutput | CopyFlowOutput[],
  originalData?: any[],
  productName?: string
): void {
  exportAndDownload(content, 'csv', productName, originalData)
}

/**
 * Export and download XLSX file
 */
export function exportAndDownloadXLSX(
  content: CopyFlowOutput | CopyFlowOutput[],
  originalData?: any[],
  productName?: string
): void {
  exportAndDownload(content, 'xlsx', productName, originalData)
}

/**
 * Export and download JSON file
 */
export function exportAndDownloadJSON(
  content: CopyFlowOutput | CopyFlowOutput[],
  metadata?: Partial<ExportMetadata>,
  productName?: string
): void {
  const defaultMetadata: ExportMetadata = {
    generatedAt: new Date().toISOString(),
    totalItems: Array.isArray(content) ? content.length : 1,
    inputMethod: 'text',
    platformsGenerated: ['universal'],
    generationsUsed: Array.isArray(content) ? content.length : 1,
    language: 'en',
    writingStyle: 'professional'
  }
  
  const fullMetadata = { ...defaultMetadata, ...metadata }
  const firstItem = Array.isArray(content) ? content[0] : content
  
  exportAndDownload(content, 'json', productName || firstItem.productTitle)
}

/**
 * Compress export data for bulk exports
 */
export async function compressExportData(data: string): Promise<Blob> {
  try {
    // Use JSZip for better cross-browser compatibility
    const zip = new JSZip();
    
    // Add data to zip
    zip.file("export.txt", data);
    
    // Generate zip blob with compression
    const blob = await zip.generateAsync({
      type: "blob",
      compression: "DEFLATE",
      compressionOptions: {
        level: 9 // Maximum compression
      }
    });
    
    return blob;
  } catch (error) {
    console.error('Compression error:', error);
    
    // Fallback to uncompressed data
    return new Blob([data], { type: 'text/plain' });
  }
}

/**
 * Get total element count for statistics
 */
function getTotalElementCount(content: CopyFlowOutput): number {
  let count = 0
  
  // Main content (5 items)
  count += 5
  
  // Marketing content
  count += content.bulletPoints.length
  count += content.keyFeatures.length
  count += content.tags.length
  count += 1 // Amazon keywords
  
  // Viral content
  count += content.viralContent.tiktokHooks.length
  count += content.viralContent.instagramCaptions.length
  
  // Audience content
  count += 1 // Primary audience
  count += content.targetAudience.painPoints.length
  count += content.targetAudience.desires.length
  
  // Psychology content
  count += content.emotionalHooks.length
  count += content.conversionTriggers.length
  count += content.trustSignals.length
  count += content.urgencyElements.length
  count += content.socialProof.length
  
  // Competitive content
  count += content.competitorAdvantages.length
  count += 1 // Price anchor
  count += content.keywordGaps.length
  
  return count
}

/**
 * Validate content before export
 */
export function validateContentForExport(content: CopyFlowOutput): { valid: boolean; errors: string[] } {
  const errors: string[] = []
  
  // Check required fields
  if (!content.productTitle?.trim()) {
    errors.push('Product title is missing')
  }
  
  if (!content.productDescription?.trim()) {
    errors.push('Product description is missing')
  }
  
  if (!content.seoTitle?.trim()) {
    errors.push('SEO title is missing')
  }
  
  if (!content.metaDescription?.trim()) {
    errors.push('Meta description is missing')
  }
  
  // Check arrays
  if (!content.bulletPoints || content.bulletPoints.length === 0) {
    errors.push('Bullet points are missing')
  }
  
  if (!content.keyFeatures || content.keyFeatures.length === 0) {
    errors.push('Key features are missing')
  }
  
  if (!content.viralContent?.tiktokHooks || content.viralContent.tiktokHooks.length === 0) {
    errors.push('TikTok hooks are missing')
  }
  
  return {
    valid: errors.length === 0,
    errors
  }
}

/**
 * Get export statistics
 */
export function getExportStatistics(content: CopyFlowOutput): {
  totalElements: number
  contentSections: number
  characterCount: number
  wordCount: number
} {
  const txtContent = exportToTXT(content)
  
  return {
    totalElements: getTotalElementCount(content),
    contentSections: 6,
    characterCount: txtContent.length,
    wordCount: txtContent.split(/\s+/).length
  }
}

/**
 * Preview export content (first 500 characters)
 */
export function previewExport(content: CopyFlowOutput): string {
  const txtContent = exportToTXT(content)
  return txtContent.substring(0, 500) + (txtContent.length > 500 ? '...' : '')
}

/**
 * Get file size estimate for export format
 */
export function getExportSizeEstimate(
  content: CopyFlowOutput | CopyFlowOutput[],
  format: ExportFormat
): string {
  const contentArray = Array.isArray(content) ? content : [content]
  let sizeBytes = 0
  
  switch (format) {
    case 'txt':
      // Estimate TXT size (first item only)
      sizeBytes = exportToTXT(contentArray[0]).length * 2
      break
      
    case 'csv':
      // Estimate CSV size
      const csvSample = exportToCSV(contentArray.slice(0, 1))
      sizeBytes = csvSample.length * contentArray.length * 1.2
      break
      
    case 'json':
      // Estimate JSON size
      const jsonSample = exportToJSON(contentArray.slice(0, 1), {
        generatedAt: new Date().toISOString(),
        totalItems: contentArray.length,
        inputMethod: 'text',
        platformsGenerated: ['universal'],
        generationsUsed: contentArray.length,
        language: 'en',
        writingStyle: 'professional'
      })
      sizeBytes = jsonSample.length * contentArray.length * 1.1
      break
      
    case 'xlsx':
      // XLSX is more complex, use a rough estimate
      sizeBytes = 10000 * contentArray.length
      break
  }
  
  // Format size
  if (sizeBytes < 1024) {
    return `${sizeBytes} bytes`
  } else if (sizeBytes < 1024 * 1024) {
    return `${(sizeBytes / 1024).toFixed(1)} KB`
  } else {
    return `${(sizeBytes / (1024 * 1024)).toFixed(1)} MB`
  }
}

/**
 * Check if export format is supported for bulk export
 */
export function isBulkExportSupported(format: ExportFormat, itemCount: number): boolean {
  const limits = {
    txt: 1, // TXT only supports single item
    csv: 10000,
    xlsx: 5000,
    json: 10000
  }
  
  return itemCount <= limits[format]
}

// Export utilities for convenience
export const ExportManager = {
  exportToTXT,
  exportToCSV,
  exportToXLSX,
  exportToJSON,
  downloadFile,
  generateFileName,
  exportAndDownloadTXT,
  exportAndDownloadCSV,
  exportAndDownloadXLSX,
  exportAndDownloadJSON,
  exportAndDownload,
  validateContentForExport,
  getExportStatistics,
  previewExport,
  compressExportData,
  getExportSizeEstimate,
  isBulkExportSupported,
  convertToCopyFlowColumns,
  generateCopyFlowColumns
} as const

// Export format constants
export const EXPORT_FORMATS = {
  TXT: 'txt',
  CSV: 'csv',
  XLSX: 'xlsx',
  JSON: 'json'
} as const

export type ExportFormat = typeof EXPORT_FORMATS[keyof typeof EXPORT_FORMATS]